本题要求不高于logn的复杂度解题，明示使用二分法。但常规的二分法只能返回一个目标，因此需要做出改进。

定义两个二分法函数，分别寻找target首次出现的位置和最后出现的位置，即代码中的Dichotomyl和Dichotomyr。具体的实现细节不多做解释，和基础的二分法一致，仅在判断退出的条件上有差异，可以自行举例验证。

```
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if target not in nums:
            return [-1, -1]
        
        #Dichotomyr，寻找目标最后出现的位置
        def Dichotomyr(nums: List[int], target: int):
            n = len(nums)
            left, right = 0, n - 1
            while left < right:
                mid = left + right + 1 >> 1
                if nums[mid] <= target:
                    left = mid
                elif nums[mid] > target:
                    right = mid - 1
            return left
        
        #Dichotomyl，寻找目标的初始位置
        def Dichotomyl(nums: List[int], target: int):
            n = len(nums)
            left, right = 0, n - 1
            while left < right:
                mid = left + right >> 1
                if nums[mid] >= target:
                    right = mid
                else:
                    left = mid + 1
            return left
        
        #直接返回列表，列表中调用二分法函数
        return [Dichotomyl(nums, target), Dichotomyr(nums, target)]
```
